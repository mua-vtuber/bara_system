# 제미니 보안 경고 리뷰 (Gemini Security Warning Review)

**날짜:** 2026년 2월 4일
**작성자:** Gemini CLI (Codebase Investigator)

## 개요
프로젝트 전체(백엔드 및 프론트엔드)를 대상으로 보안 취약점을 분석한 결과입니다. 전반적으로 최신 보안 관행을 잘 따르고 있으나, 즉시 조치가 필요한 몇 가지 잠재적 위험 요소가 식별되었습니다.

## 🚨 주요 보안 취약점

### 1. API 보안 설정 (CORS) - ⚠️ 위험 (Critical)
*   **위치:** `backend/app/main.py`
*   **문제점:** Cross-Origin Resource Sharing (CORS) 설정이 모든 도메인을 허용(`allow_origins=['*']`)하도록 구성되어 있습니다.
*   **보안 위험:** 악의적인 웹사이트가 사용자의 브라우저를 통해 백엔드 API에 무단 요청을 보낼 수 있는 위험이 있습니다. 인증된 사용자의 세션을 악용한 요청 위조가 가능해집니다.
*   **권장 조치:** `allow_origins` 목록을 프론트엔드가 실제로 배포되는 특정 도메인(예: `http://localhost:5173`, `https://your-domain.com`)으로 제한해야 합니다.

### 2. 백업 데이터 내 민감 정보 노출 - ⚠️ 위험 (Critical)
*   **위치:** `backend/app/services/backup.py` (`export_backup` 함수)
*   **문제점:** 시스템 백업 생성 시 API 키, 비밀번호 해시, 외부 서비스 자격 증명 등 민감한 설정 정보가 평문 JSON 형태로 포함되어 내보내집니다.
*   **보안 위험:** 백업 파일(.json)이 유출될 경우, 시스템 관리자 권한 및 연동된 외부 플랫폼(Discord, Telegram 등)의 제어권을 모두 탈취당할 수 있습니다.
*   **권장 조치:** 
    *   백업 데이터 생성 시 민감한 필드(비밀번호, 토큰 등)를 자동으로 제외하거나 마스킹 처리해야 합니다.
    *   또는 백업 파일 생성 시 암호화를 강제하고 복구 시에만 복호화하도록 로직을 변경해야 합니다.

### 3. WebSocket 인증 방식 - ⚠️ 주의 (Warning)
*   **위치:** `backend/app/api/websocket/chat.py`
*   **문제점:** WebSocket 연결 인증 토큰이 URL 쿼리 파라미터(`ws://...?token=<token>`)로 전달됩니다.
*   **보안 위험:** URL은 브라우저 히스토리, 프록시 서버 로그, 웹 서버 액세스 로그 등에 평문으로 남을 수 있어 토큰 노출 위험이 높습니다.
*   **권장 조치:** 
    *   가능하다면 HTTP 헤더(Cookie 또는 Authorization)를 통해 토큰을 전달하도록 변경합니다.
    *   또는 WebSocket 연결 수립 직후 첫 번째 메시지로 인증 토큰을 전송하여 검증하는 핸드셰이크 방식을 사용합니다.

### 4. 동적 SQL 사용 (백업 복구) - ⚠️ 주의 (Warning)
*   **위치:** `backend/app/services/backup.py` (`import_backup` 함수)
*   **문제점:** 백업 데이터를 DB에 복원할 때, JSON 키(컬럼명)를 사용하여 SQL 쿼리 문자열을 동적으로 생성합니다.
*   **보안 위험:** 조작된 백업 파일을 사용할 경우, 컬럼명 부분에 악의적인 SQL 구문을 삽입하는 제한적인 SQL Injection 공격이 가능할 수 있습니다.
*   **권장 조치:** 동적으로 생성되는 컬럼명에 대해 화이트리스트 검증을 수행하여, DB 스키마에 실제로 존재하는 유효한 컬럼인지 확인 후 쿼리를 생성해야 합니다.

### 5. API 속도 제한 (Rate Limiting) 부재
*   **문제점:** 외부 API 호출에 대한 제한은 구현되어 있으나, 로그인 시도나 설정 변경과 같은 내부 중요 API에 대한 명시적인 속도 제한이 부족합니다.
*   **보안 위험:** 무차별 대입 공격(Brute Force)이나 서비스 거부(DoS) 공격에 취약할 수 있습니다.
*   **권장 조치:** `slowapi` 등의 라이브러리를 도입하여 주요 엔드포인트에 IP 기반 또는 사용자 기반의 Rate Limiting을 적용하십시오.

---

## ✅ 양호한 보안 관행 (Positive Findings)

*   **강력한 비밀번호 해싱:** `backend/app/services/auth.py`에서 PBKDF2-HMAC-SHA256 알고리즘과 600,000회 반복을 사용하여 비밀번호를 안전하게 저장하고 있습니다. 이는 GPU를 이용한 크래킹 공격에 대해 높은 저항성을 가집니다.
*   **안전한 세션 쿠키:** 인증 토큰 저장 시 `HttpOnly` 및 `SameSite=lax` 속성을 사용하여 JavaScript를 통한 쿠키 탈취(XSS) 및 CSRF 공격을 방어하고 있습니다.
*   **SQL Injection 방지:** 대부분의 데이터베이스 상호작용에서 `aiosqlite`의 매개변수 바인딩(`?` placeholder)을 사용하여 SQL Injection을 원천적으로 차단하고 있습니다.
*   **민감 정보 필터링:** 봇이 생성하는 텍스트에서 API 키 패턴을 감지하여 마스킹하는 `SecurityFilter`가 구현되어 있어 정보 유출을 능동적으로 방지합니다.
*   **프론트엔드 XSS 방어:** React의 기본 이스케이프 기능을 활용하며, `dangerouslySetInnerHTML`과 같은 위험한 함수의 사용이 발견되지 않았습니다.

## 🏁 종합 결론
이 프로젝트는 기본적인 보안 원칙을 잘 준수하고 있으나, 운영 환경 배포 전 **CORS 설정 강화**와 **백업 파일 보안 처리**는 필수적으로 해결해야 합니다. 이러한 조치를 통해 시스템의 안전성을 크게 향상시킬 수 있습니다.
